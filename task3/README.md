# Задание 3

## Краткое описание задания

Дана информация о:
1) закупках (поставки яблок и карандашей два раза в месяц),
2) продажах (лог транзакций, по записи на каждую проданную позицию),
3) инвентарь (месячные данные общего количества яблок и карандашей на складе).

Нужно:
1) Состояние склада на каждый день,
2) Месячные данные о количестве сворованного товара,
3) Агрегированные данные об объемах продаж и количестве сворованной продукции по штату и году.
  
## Теория

Нам дано много файлов. Их названия можно условно поделить на 2 части: префикс - "MS-b1-", "MS-s1-"  и т.д. и суффикс - "supply.csv", "sell.csv", "invenory.csv". Мы отдельно работаем с каждым суффиксом, с помощью которого получаем доступ к 3 файлам: закупки, продажи и инвентарь.

### sell.csv

Файл состоит из записей вида 

date       | sku_num
---        | --- 
2006-01-01 | MS-s4-ap-6d174403-2b63-4eac-b4e7-ee52717945fd
2006-01-01 | MS-s4-ap-d537536e-088c-44a9-bde0-66ddf3f9eaf2
2006-01-01 | MS-s4-pe-6188ebf9-bfbc-4b6e-81fa-ccc7e2bd71c3

* MS - название штата
* s4 - магазин
* ap/pe - наименование товара - яблоко/карандашей
* 6188ebf9-bfbc-4b6e-81fa-ccc7e2bd71c3 - идентификационный код

### supply.csv

Файл состоит из записей вида 

date       | apple | pen
---        | ---   | ---
2006-01-01 | 2999  | 332
2006-01-15 | 3084  | 337
2006-02-01 | 2971  | 341

* apple/pen - число яблок/карандашей, поступивших на склад. На склад они поступают 1-го и 15-го числа каждого месяца.

### inventory.csv

Файл состоит из записей вида 

date       | apple | pen
---        | ---   | ---
2006-01-31 | 3140  | 339
2006-02-28 | 6450  | 759
2006-03-31 | 9517  | 1142

* apple/pen - число яблок/карандашей, хранящихся на складе. Учет товаров происходил 1 раз в месяц.

Сначала подсчитаем число яблок и ручек, проданных за каждый день. Для этого в файле `sell.csv` просто подсчитываем число строк, содержащих "pe"/"ap" для каждого дня. Далее составляем общую таблицу вида:

date       | apple | pen 
---        |  ---  | ---
2006-01-01 |  85   | 9
2006-01-02 |  97   | 10
2006-01-03 |  96   | 8

### Состояние склада на каждый день

Мы знаем, что поступления на склад происходят только 2 раза в месяц. Но с такими датами неудобно работать. Поэтому мы расширим inventory.csv, заполнив недостающие значения нулями. Отсюда вычтем то, что мы продали - 1 и 15 числа будут положительные значения в таблице, в остальные дни - отрицательные (ничего на склад не поступало, были только продажи). Далее просуммируем за каждый месяц - получим состояние склада на каждый день





## Подход к решению

Для начала нам необходимо узнать названия всех файлов

1. Чтение данных из `training.csv`
* Чтение производится `командой pd.read_csv('training.csv')`
	+ Библиотека `pandas`

2. Проверка на стационарность
    * Визуальная оценка
    		* `ts.rolling().mean()` - Скользящее среднее
			+ Возвращает скользящее среднее
			+ Библиотека `pandas`
		* `ts.rolling().std()` - Стандартное отклонение
			+ Возвращает стандартное отклонение
			+ Библиотека `pandas`
        	* Строим вывод о стационарности ряда по визуальной оценке
    * Тест Дики-Фуллера
        	+ `sm.tsa.adfuller(ts)` - проводит тест Дики-Фуллера
			* ts - временной ряд
			* Возвращает массив с данными 
				+ 0 => adf
				+ 4 => critical values
			* Библиотека `statsmodels`
        	+ Анализируем полученные из функции параметры
        	+ Строим вывод о стационарности данного ряда

3. Разложение временного ряда на тренд, сезональность остаток в соответствии с аддитивной и мультипликативной моделями
    * `models(data, model_s, title)` реализует разложение на соответствующие модели
		+ data - временной ряд
		+ model_s - параметр для функции decomp, которая осуществляет разложение временного ряда
		+ title - название для графика
		+ С помощью функции `seasonal_decompose` раскладываем временной ряд на тренд, сезональность и остаток, после чего отрисовываем их и прогоняем через тест Дики-Фуллера, который анализирует стационарность рядов
    * `seasonal_decompose(data.Value, model)`
		+ data.Value - столбец значений временного ряда
		+ model - 'additive' или 'multiplicate'
		+ Возвращает decompose
			* decompose.trend - тренд исходного ряда
			* decompose.resid - остаток исходного ряда
			* decompose.seasonal - сезонность исходного ряда
		+ Библиотека `statsmodels`
	* Строим вывод на основании полученных результатов
4. Поиск коэффициента интегрируемости ряда
	* `findOrder(ts, isPrint)` - Возвращает коэффициент интегрированности ряда
		+ ts - временной ряд
		+ isPrint - флаг: если True - печать в тесте Дики-Фуллера, если False - ничего не выводит
5. Подбираем нужные параметры с помощью функции автокорреляции и функции частичной автокорреляции
	* `acf(ts, nlags)` - находит автокорреляцию временного ряда
		+ ts - временной ряд
		+ nlags - число лагов для автокорреляции
		+ Зачем нужна? Помогает найти порядок q модели MA(q) для построения модели ARIMA(p, d, q)
		+ Возвращает массив с значениями функции
		+ Библиотека `statsmodels`
	* `pacf(ts, nlags)` - находит частичную автокорреляцию временного ряда
		+ ts - временной ряд
		+ nlags - число лагов для частичной автокорреляции
		+ Зачем нужна? Помогает найти порядок p модели AR(p) для построения модели ARIMA(p, d, q)
		+ Возвращает массив с значениями функции
		+ Библиотека `statsmodels`
	* Функции автокорреляции и частичной автокорреляции - дискретные, число различных значений равно лагу (в обоих случаях по 20). Соответствующие коэффициенты определяются по правилу - берется целая часть наибольшего значения. В обоих случаях наибольшее значение равно 1.0 и достигается оно на нулевом элементе (в обоих случаях).
6. ARIMA-модель
	* `ARIMA(ts, order=(p, k, q))` - строит модель ARIMA на основе временного ряда ts
		+ ts - временной ряд
		+ order - порядки для модели
		+ Возвращает объект ARIMA
		+ Библиотека `statsmodels`
	* `model.fit()` - Прогоняем ARIMA-модель через фильтр Калмана
		+ **Опр.** Фильтр Калмана - мощнейщий инструмент фильтрации данных. При фильтрации используется информация о физике самого явления.
		+ Возвращает объект ARIMAResults - содержит также и результаты предсказаний, которые можно выводить и использовать в дальнейших прогнозах
		+ Метод класса ARIMA
	* `model.predict(start='1988-12-01', end='1993-12-01', typ='levels', dynamic=True)` - строим предсказание на тестовой выборке
		+ start - определяет с какой позиции начать предсказывать
		+ end - определяет до какой позиции предсказывать
		+ typ='linear' - строит предсказание по уровням временного ряда
		+ dynamic=True - повышает точность предсказания
		+ Возвращает предсказанные значения
		+ Библиотека `statsmodels`
		
7) SARIMAX
	* `SARIMAX(ts, order=(p, k, q), seasonal_order=(p,k,q,s))` - строит модель SARIMAX на основе временного ряда ts
		+ ts - временной ряд
		+ order - порядок для модели
		+ seasonal_order - сезональный порядок - параметры для авторегрессии, интегрированности, скользящего среднего и сезональности
		+ **Опр.** Сезональность (применительно к данной модели) - число периодов в сезоне (12 - для ежемесячных данных)
		+ Возвращает объект SARIMAX
		+ Библиотека `statsmodels`
	* `model.fit()` - Прогоняем ARIMA-модель через фильтр Калмана
		+ Полная аналогия с моделью ARIMA
		+ Возвращает объект MLEResults - содержит также и результаты предсказаний, которые можно выводить и использовать в дальнейших прогнозах
		+ Метод класса SARIMAX
	* `model_res.predict(start='1988-12-01', end='1993-12-01', dynamic=True)`
		+ start - определяет с какой позиции начать предсказывать
		+ end - определяет до какой позиции предсказывать
		+ dynamic=True - повышает точность предсказания
		+ Возвращает предсказанные значения
		+ Библиотека `statsmodels`
		
8) R2 score
	* `r2_score(y_true, y_pred)` - подсчитывает r2 score между реальной выборкой и предсказанной
		+ y_true - реальные значения
		+ y_pred - предсказанные значения
		+ Библиотека `sklearn.metrics`
		+ Вовзращает r2 score 

9) AIC
	* `model.aic` - выводит значение критерия - вычисляется в процессе построения статистической модели

10) PEP8
	* PEP8 описывает соглашение о том, как писать код для языка python
	* Код данные соглашения выполняет
	
11) Использование графической библиотеки Bokeh
	* Использование данной бибилиотеки, в целом, аналогично использованию билиотеки Matplotlib, с которой мы ознакомились в прошлом семестре
	* `p = TimeSeries(ts, width=900, height=500, legend=False, title="Time Series", ylabel='Values', xlabel='Time', color='blue')`
		+ ts - временной ряд
		+ legend=False - убрать легенду
		+ title='Time Series' - добавить заголовок
		+ xlable='Time' - добавить название оси X
		+ ylable='Values' - добавить название оси Y
		+ color='blue' - выбрать цвет графика
		+ width=900, height=500 - ширина, высота
	* `show(p)` - вывести изображение на экран
	* `output_notebook()` - использовать Jupiter Notebook в качестве файла, в который будут выводиться изображения

## Инструкции по запуску
1) Поместить в папку 'input' файлы для обработки
2) Cell -> Run All
3) Результат будет находиться в папке 'output'

## Необходимое ПО

### Библиотеки:	
1) **Pandas**
* Для работы с временными рядами
2) **Numpy** 
* Для работы с массивами
3) **OS**
* Для работы с файлами и директориями
4) **Shutil**
* Для удаления директории и её содержимого

### Программы:
1) Jupyter Notebook

## Участники 

1) Горбунов Александр - 312 гр.
* Визуальная проверка на стационарность
* Разложение модели на тренд, сезональность и остаток в соответствии с аддитивной и мультипликативной моделями
* ARIMA модель
* Написал README.md
* Работа с библиотекой Bokeh

2) Гулиев Юрий - 312 гр.
* Проверка на стационарность с помощью теста Дики-Фуллера
* Поиск коэффициента интегрированности ряда, подбор параметров с использованием функций автокорреляции и частичной автокорреляции
* SARIMAX модель
* Отбор моделей согласно информационному критерию Акаике
* PEP8

3) Михаил Тихонов
